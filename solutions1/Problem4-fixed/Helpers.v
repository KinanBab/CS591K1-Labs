Require Import Frap Modeling Hoare.

(* Three tactic definitions that we won't explain.  The overall tactic
 * [ht] tries to prove Hoare triples, essentially by repeated application of the
 * hoare logic rules.
 * As a side effect, ht will produce several simplified proof obligations (goals)
 * generally on the form of implication between assertions, these are obligations
 * that came up while applying the hoare logic rules, that [ht] was not able of solving
 * them automatically. *)
(* An example of such obligation is when using HtWhile rule, in order for that rule to apply
   you need to prove that (1) the current precondition implies the invariant of the loop, AND
   (2) if the invariant holds and the condition of the loop is true, the invariant should
       still hold after the loop body is executed once *)
(* [ht] is a very powerful tactic, it applies all the Hoare rules effectively completely traversing
   the program. The resulting obligations do not refer to the program directly, only the current
   (and perhaps previous) valuation and heap. This simplifies matters a lot.
   HOWEVER, this may lead to some context-erasure, the proof obligations generated by [ht] may
   have so little context in them, to explain how they came about, why they are provable, and how
   to prove them.
   If that happens during the proof, I suggest undoing [ht], and applying [ht1] several times, one step at
   a time. [ht1] will only apply one of the Hoare logic rules at a time (the only one that works, according
   to what the current statement in the program is). This gives you a chance to see how the proof is manipulated
   one step at a time. Use [simplify] or [t] if the goal becomes too big / complicated too read. *)
Ltac ht1 := apply HtSkip || apply HtAssign || apply HtWrite || eapply HtSeq
            || eapply HtIf || eapply HtWhile || eapply HtAssert
            || eapply HtStrengthenPost.

Ltac t := cbv beta; propositional; subst;
          repeat match goal with
                 | [ H : ex _ |- _ ] => invert H; propositional; subst
                 end;
          simplify;
          repeat match goal with
                 | [ _ : context[?a <=? ?b] |- _ ] => destruct (a <=? b); try discriminate
                 | [ H : ?E = ?E |- _ ] => clear H
                 end; simplify; propositional; auto; try equality; try linear_arithmetic.

Ltac ht := simplify; repeat ht1; t.

Ltac comparison_bool_to_prop :=
  (repeat match goal with
  | [ H: Nat.eqb _ _ = true |- _ ] => apply Nat.eqb_eq in H
  | [ H: Nat.eqb _ _ = false |- _ ] => apply Nat.eqb_neq in H
  | [ H: Nat.leb _ _ = true |- _ ] => apply Nat.leb_le in H
  | [ H: Nat.leb _ _ = false |- _ ] => apply Nat.leb_nle in H
  | [ H: Nat.ltb _ _ = true |- _ ] => apply Nat.ltb_lt in H
  | [ H: Nat.ltb _ _ = false |- _ ] => apply Nat.ltb_nlt in H
  | [ |- Nat.eqb _ _ = true] => apply Nat.eqb_eq
  | [ |- Nat.eqb _ _ = false] => apply Nat.eqb_neq
  | [ |- Nat.leb _ _ = true] => apply Nat.leb_le
  | [ |- Nat.leb _ _ = false] => apply Nat.leb_nle
  | [ |- Nat.ltb _ _ = true] => apply Nat.ltb_lt
  | [ |- Nat.ltb _ _ = false] => apply Nat.ltb_nlt
  end).